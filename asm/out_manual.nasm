section .text

	; for i in range 3
		; for ii in range lenof(big.i)
			; for iii in range 2 (which is lenof(big.i.ii.iii), a constant)
				; iv is a bare type, so this is in .data
			mov [big.i.ii], big.i.ii.iii + 8
			mov [big.i.ii], lenof(big.i.ii.iii)
		mov qword[big.i + 0], big.i.ii + 8
		mov qword[big.i + 8], lenof(big.i.ii)
	mov qword[rsp + i + 0], big.i + 8
	mov qword[rsp + i + 8], lenof(big.i)

section .data

	; ===== expanding asm-like =====
section .text
	mov qword[vardata.hellos + 8 + 0*8], vardata.hellos.1 + 8
	mov qword[vardata.hellos + 8 + 1*8], 5
	mov qword[vardata.hellos + 8 + 2*8], vardata.hellos.1 + 8 + 5 + 8
	mov qword[vardata.hellos + 8 + 3*8], 3
	mov qword[vardata.hellos + 8 + 4*8], vardata.hellos.1 + 8 + 5 + 8 + 3 + 8
	mov qword[vardata.hellos + 8 + 5*8], 5
	mov qword[vardata.hellos + 8 + 6*8], vardata.hellos.1 + 8 + 5 + 8 + 3 + 8 + 5 + 8
	mov qword[vardata.hellos + 8 + 7*8], 9

	mov qword[rsp + 0], vardata.hellos + 8
	mov qword[rsp + 8], 4

section .data
	vardata.hellos:
		dq 0
		dq 0x1122334455667788, dq -1
		dq 0x1122334455667788, dq -1
		dq 0x1122334455667788, dq -1
		dq 0x1122334455667788, dq -1

	vardata.hellos.1:
		dq 0 db "hello"
		dq 0 db "hey"
		dq 0 db "haiii"
		dq 0 db "greetings"


	; ---- expanding literally ----
		; for ii in range lenof(big.0)
			; for iii in range 2 (which is lenof(big.0.ii.iii), a constant)
				; iv is a bare type, so this is in .data
			mov [big.0.ii], big.0.ii.iii
			mov [big.0.ii], lenof(big.0.ii.iii)
		mov [big.0 + 0], big.0.ii
		mov [big.0 + 8], lenof(big.0.ii)
	mov qword[rsp + 0 + 0], big.0
	mov qword[rsp + 0 + 8], lenof(big.0)

		; for ii in range lenof(big.1)
			; for iii in range 2 (which is lenof(big.1.ii.iii), a constant)
				; iv is a bare type, so this is in .data
			mov [big.1.ii], big.1.ii.iii
			mov [big.1.ii], lenof(big.1.ii.iii)
		mov [big.1 + 0], big.1.ii
		mov [big.1 + 8], lenof(big.1.ii)
	mov qword[rsp + 16 + 0], big.1
	mov qword[rsp + 16 + 8], lenof(big.1)

		; for ii in range lenof(big.2)
			; for iii in range 2 (which is lenof(big.2.ii.iii), a constant)
				; iv is a bare type, so this is in .data
			mov [big.2.ii], big.2.ii.iii
			mov [big.2.ii], lenof(big.2.ii.iii)
		mov [big.2 + 0], big.2.ii
		mov [big.2 + 8], lenof(big.2.ii)
	mov qword[rsp + 32 + 0], big.2
	mov qword[rsp + 32 + 8], lenof(big.2)
	

section .data
	msg:
		dq 0
		db "Hewwoo >.<", 0x0a


############# used to be in test.nasm
; This code is generated by Triops (in first person). If I have something to say, it'll be prepended with 'Triops'.
; Triops version: 0

global _start

section .text
_start:
	; Triops: Global variable intialization
	sub rsp, 16; Triops: This is the size of all variables on the stack

	mov qword[vardata.hellos + 8 + 0*8], vardata.hellos.in + 8
	mov qword[vardata.hellos + 8 + 1*8], 6
	mov qword[vardata.hellos + 8 + 2*8], vardata.hellos.in + 8 + 6 + 8
	mov qword[vardata.hellos + 8 + 3*8], 4
	mov qword[vardata.hellos + 8 + 4*8], vardata.hellos.in + 8 + 6 + 8 + 4 + 8
	mov qword[vardata.hellos + 8 + 5*8], 6
	mov qword[vardata.hellos + 8 + 6*8], vardata.hellos.in + 8 + 6 + 8 + 4 + 8 + 6 + 8
	mov qword[vardata.hellos + 8 + 7*8], 10

	mov qword[rsp + 0], vardata.hellos + 8
	mov qword[rsp + 8], 4

	; Triops: User code
	mov rax, qword[rsp + 0]
	mov rsi, qword[rax + 32]
	mov rdx, qword[rax + 40]

	mov rax, 1
	mov rdi, 1
	syscall

	; Triops: leaving the stack as I found it
	add rsp, 16; Triops: This was the size of all variables on the stack

	; Triops: Adding the unix exit, in case the user doesn't add one
	mov rax, 60; Triops: 60 is exit
	mov rdi, 0; Triops: 0 is success
	syscall

section .data
	vardata.hellos:
		dq 0
		dq 0x1122334455667788, -1
		dq 0x1122334455667788, -1
		dq 0x1122334455667788, -1
		dq 0x1122334455667788, -1

	vardata.hellos.1:
		dq 0
		db "hello", 10
		dq 0
		db "hey", 10
		dq 0
		db "haiii", 10
		dq 0
		db "greetings", 10